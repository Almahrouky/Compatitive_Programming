#include <bits/stdc++.h>
using namespace std;

struct SegTree{
    vector<int>tree;
    int oldN;

    void build(int n, int *arr){
        // if n is not a perfect power of 2
        if(__builtin_popcount(n) != 1)
            oldN = 1<<(__lg(n) + 1);
        else
            oldN = n;
        tree.resize(oldN << 1);
        for(int i = 0; i < n; ++i)
            tree[i + oldN] = arr[i];
        for(int i = oldN - 1; i; --i)
            tree[i] = tree[i<<1] + tree[i<<1 | 1];
    }

    int query(int ql, int qr, int k, int sl, int sr){
        // if the segment is totaly inside the query
        if(ql <= sl && sr <= qr)
            return tree[k];
        if(ql > sr || sl > qr)
            return 0;
        
        int mid = (sl + sr)/2;
        return query(ql, qr, k<<1, sl, mid) + query(ql, qr, k<<1 | 1, mid + 1, sr);
    }

    // point update
    void update(int ql, int qr, int v, int k, int sl, int sr){
        // if the segment is totaly inside the update range
        // ql == qr -> sl == sr
        if(ql <= sl && sr <= qr)
            tree[k] = v;
        if(ql > sr || sl > qr)
            return ;
        
        int mid = (sl + sr)/2;
        update(ql, qr, v, k<<1, sl, mid);
        update(ql, qr, v, k<<1 | 1, mid + 1, sr);
        tree[k] = tree[k<<1] + tree[k<<1 | 1];
    }
};

int main() {
    ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);
    
    return 0;
}
